## 1. 상속(inheritance)
### 1-1 상속의 정의와 장점
- 상속: 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것.
- 만들려는 클래스의 이름 뒤에 상속받고자 하는 클래스의 이름을 `'extends'`와 함께 써주면된다.
- 자바에서는 단일 상속만을 허용한다.
- 상속해주는 클래스를 '조상 클래스', 상속 받는 클래스를 '자손 클래스' 라고 한다.
```java
class Parent{}                  //조상 클래스

class Child extends Parent{}    //자손 클래스

class Child extends Parent, GrandParent{}   //다음과 같이 사용할 수 없다.

```
- 생성자와 초기화 블럭은 상속되지 않는다. `멤버`만 상속된다.
- 자손 클래스의 멤버 개수는 조상클래스보다 항상 같거나 많다.
- 자손 클래스의 인스턴스를 생성하면 조상 클래스의 멤버와 자손 클래스의 멤버가 합쳐진 하나의 인스턴스로 생성된다.

### 1-2 클래스간의 관계 결정하기
- 상속관계: '~은 ~이다.(is-a)'
- 포함관계: '~은 ~을 가지고 있다.(has-a)'
- 관계를 문장으로 만들어보면 어떻게 처리해야할지 명확해진다.

## 2. 오버라이딩(Overriding)
- 오버라이딩: 조상클래스로부터 상속받은 메서드의 내용을 변경하는 것
- 자손 클래스에서 오버라이딩 하는 메서드는 조상 클래스의 메서드와 `이름`, `매개변수`, `반환타입`(=선언부) 세가지가 같아야한다.
- 조상 클래스의 메서드를 자손 클래스에서 오버라이딩할 때
    1. 접근 제어자를 조상 클래스의 메서드보다 좁은 범위로 변경할 수 없다.
    2. 예외는 조상 클래스의 메서드보다 많이 선언할 수 없다.
    3. 인스턴스메서드를 static메서드로 또는 그 반대로 변경할 수 없다.

### 2-1 오버로딩 vs 오버라이딩
- 오버로딩(overloading): 기존에 없는 새로운 메서드를 정의하는 것 (new)
- 오버라이딩(overriding): 상속받은 메서드의 내용을 변경하는 것 (change, modify)

### 2-2 super
- super: 자손클래스에서 조상클래스로부터 상속받은 멤버를 참조하는데 사용하는 참조변수.
- 상속받은 멤버와 자신의 클래스에 정의된 이름이 같을 때 super를 붙여서 구별할 수 있다.

### 2-3 super() - 조상클래스의 생성자
- super(): 조상클래스의 생성자를 호출하는데 사용
- Object 클래스를 제외한 모든 클래스의 생성자 첫 줄에 생성자 `this()` 또는 `super()`를 호출해야 한다.
- 그렇지 않으면 컴파일러가 자동적으로 `'super();'`를 생성자의 첫 줄에 삽입한다.
- 조상 클래스의 멤버변수는 조상의 생성자에 의해 초기화 되도록 해야한다.

## 3. package와 import
### 3-1 패키지(package)
- 패키지: 클래스의 묶음으로 서로 관련된 클래스들끼리 그룹단위로 묶어 놓아 효율적으로 관리할 수 있다.
- 하나의 소스파일에는 첫 번째 문장으로 단 한번의 패키지 선언만을 허용한다.
- 모든 클래스는 반드시 하나의 패키지의 속해야 한다.
- 패키지는 점(.)을 구분자로 하여 계층구조로 구성할 수 있다.
- 패키지는 물리적으로 클래스 파일(.class)을 포함하는 하나의 디렉토리이다.
- 소스파일을 작성할 때 패키지를 선언하지 않는다면 '이름없는 패키지(unnamed package)'에 속하게 된다. 패키지를 지정하지 않는 모든 클래스들은 같은 패키지에 포함된다.

### 3-2 import문
- 클래스 작성 전에 import문으로 사용하고자 하는 클래스의 패키지를 미리 명시해주면 소스코드에 사용되는 클래스이름에서 패키지명은 생략할 수 있다.
- 컴파일 시 컴파일러는 import문을 통해 소스파일에 사용된 클래스들의 패키지를 알아 낸 다음, 모든 클래스이름 앞에 패키지명을 붙여 준다.
- 모든 소스파일(.java)에서 import문은 package 다음, 클래스 선언문 이전에 위치해야 한다.
- 모든 소스파일에는 `'java.lang.*'`의 import문이 묵시적으로 선언되어 있다. 
- static import는 패키지 클래스의 정적 멤버를 선언함으로서 static 멤버를 호출할 때 클래스 이름을 생략할 수 있게 해준다.

```java
import static java.lang.Integer.*;      // Integer클래스의 모든 static 메서드

import static java.lang.Math.random;    // Math.random()만. 괄호 안붙임.

import static java.lang.System.out;     // System.out을 out만으로 참조가능 -> out

System.out.println(Math.random()); ➔ out.println(random());
```

## 4. 제어자(modifier)
### 4-1 제어자란?
- 제어자: 클래스, 변수 또는 메서드의 선언부에 함께 사용되어 부가적인 의미를 부여한다.
- 하나의 대상에 여러 제어자를 조합하여 사용하는것이 가능하다. 
- 접근 제어자는 한번에 네 가지중 하나만 사용할 수 있다.
  - 접근 제어자: public, protected, default, private
  - 그 외 제어자: static, final, abstract, native, transient, synchronized, volatile, strictfp

### 4-2 static - 클래스의, 공통적인
- static 멤버 변수(클래스 변수)는 하나의 변수를 모든 인스턴스가 공유하기 때문에 인스턴스에 관계없이 같은 값을 갖는다.
- static이 붙은 멤버변수와 메서드, 초기화 블럭은 인스턴스를 생성하지 않고도 사용할 수 있다.
- 인스턴스메서드와 static메서드는 메서드 내에서 인스턴스 멤버를 사용하는가의 차이가 있다.

### 4-3 final - 마지막의, 변경될 수 없는
- final 제어자를 변수에 사용되면 상수가 되고, 메서드에 사용되면 오버라이딩이 불가해진다. 클래스에 사용되면 자손클래스로의 확장이 불가해진다.
- final이 붙은 인스턴스변수의 경우 생성자에서 초기화되도록 할 수 있다.
- 클래스 내에 매개변수를 갖는 생성자를 선언하여, 인스턴스를 생성할 때 final이 붙은 멤버변수를 초기화하는데 필요한 값을 생성자의 매개변수로부터 제공받는다.

### 4-4 abstract - 추상의, 미완성의
- abstract는 메서드의 선언부만 작성하고 실제 수행내용은 구현하지 않은 추상 메서드를 선언하는데 사용된다.
- 또한 클래스에 사용되어 추상메서드 존재여부를 알 수 있게도 한다.
- 완성되지 않은 메소드가 존재하기 때문에 인스턴스를 생성할 수 없다.
- 클래스 자체는 쓸모없지만 다른 클래스가 이 클래스를 상속받아서 일부 메서드만 오버라이딩할 수 있다는 장점이 있다.

### 4-5 접근 제어자(access modifier)
- 접근제어자: 멤버 또는 클래스에 사용되어, 해당하는 멤버 또는 클래스를 외부에서 접근하지 못하도록 제한하는 역할을 한다.
- 접근 제어자가 사용될 수 있는 곳: 클래스, 멤버변수, 메서드, 생성자
  - private: 같은 클래스 내에서만 접근가능
  - default: 같은 패키지 내에서만 접근가능
  - protected: 같은 패키지내에서, 그리고 다른 패키지의 자손클래스에서 접근이 가능하다.
  - public: 접근 제한이 전혀 없다.
  
- 캡슐화: 클래스나 멤버에 접근 제어자를 사용하여, 클래스의 내부에 선언된 데이터를 보호하고, 외부에 불필요한 부분을 감추는 행위.

### 4-6 제어자(modifier)의 조합
- 메서드에 static과 abstract를 함께 사용 할 수 없다.
- 클래스에 abstract와 final을 동시에 사용할 수 없다.
- abstract메서드의 접근 제어자가 private일 수 없다.
- 메서드에 private과 final을 같이 사용할 필요는 없다.

## 5.다형성(polymorphism)
### 5-1 다형성이란?
- 다형성: '여러 가지 형태를 가질 수 있는 능력' 을 의미한다.
- 구체적으로는 '조상클래스 타입의 참조변수로 자손클래스의 인스턴스를 참조할 수 있도록 하였다는 것'이다.
- 반대로 자손타입의 참조변수로 조상타입의 인스턴스를 참조할 수는 없다.

### 5-2 참조변수의 형변환
- 참조 변수의 형변환도 자손타입과 조상타입 서로간의 형변환만 가능하다.
- 자손타입에서 조상타입으로의 형변환`(up-casting)`은 생략가능하지만 조상타입에서 자손 타입으로의 형변환`(down-casting)`은 생략불가능하다.
- 형변환은 참조변수의 타입을 반환하는 것이지 인스턴스를 변환하는 것은 아니기 때문에 참조변수의 형변환은 인스턴스에 아무런 영향을 미치지 않는다. 단지 참조하고 있는 인스턴스에서 사용할 수 있는 멤버의 범위(개수)를 조절하는 것 뿐이다.
- 참조변수가 가리키는 인스턴스의 자손타입으로 형변환은 허용되지 않는다.

### 5-3 instanceof연산자
- 참조변수가 참조하고 있는 인스턴스의 실제 타입을 알아보기 위해 사용한다.
- 주로 조건문에서 `'참조변수 instanceof 타입(클래스명)'`의 형태로 사용되며, 결과가 true라는 것은 검사한 타입으로 형변환이 가능하다는 것을 뜻한다.

### 5-4 참조변수와 인스턴스의 연결
- 멤버변수가 조상 클래스와 자손 클래스에 중복으로 정의된 경우, 조상타입의 참조변수를 사용했을 때는 조상 클래스에 선언된 멤버변수가 사용되고, 자손타입의 참조변수를 사용했을 때는 자손 클래스에 선언된 멤버변수가 사용된다.

### 5-5 매개변수의 다형성
- 참조형 매개변수는 메서드 호출시, 자신과 같은 타입 또는 자손타입의 인스턴스를 넘겨줄 수 있다.

### 5-6 여러 종류의 객체를 배열로 다루기
- 조상타입의 참조변수 배열을 사용하면, 공통의 조상을 가진 서로 다른 종류의 객체를 배열로 묶어서 다룰 수 있다.
- Vector로 배열의 크기를 동적으로 관리할 수 있다.