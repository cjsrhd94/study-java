## 1. 컬렉션 프레임워크(Collections Framework)
- 컬렉션 프레임워크: 데이터 군을 저장하는 클래스들을 표준화한 설계.
- 컬렉션 데이터 그룹을 크게 List, Set, Map 3가지로 분류할 수 있다.

|인터페이스|특징|
|-----|---|
|List|순서가 있는 데이터의 집합, 데이터의 중복을 허용|
|Set|순서를 유지하지 않는 데이터의 집합, 데이터의 중복을 허용하지 않음|
|Map|key와 value의 쌍으로 이루어진 데이터 집합, 순서는 유지되지 않음, 키는 중복을 허용하지 않고 값은 중복을 허용.

### 1-1 ArrayList
- ArrayList는 Object배열을 이용해서 데이터를 순차적으로 저장한다.
- 원소가 삭제될 때 마다 빈 공간을 채우기 위해 나머지 요소들이 자리이동을 한다. 따라서 요소를 삭제할 때 주의해야한다.
- ArrayList는 지정한 크기보다 더 많은 객체를 저장하면 자동적으로 늘어나지만, 이 과정에서 처리시간이 많이 소요된다. 이는 용량을 변경할 때 새로운 배열을 생성한 후 기존의 배열로부터 새로 생성된 배열로 데이터를 복사해서 넣기 때문이다. 따라서 실제 저장할 개수보다 여유를 주는 것이 좋다.

### 1-2 LinkedList
- 배열은 크기를 변경할 수 없고 중간에 데이터를 추가/삭제하는데 시간을 많이 소모한다.
- 이러한 배열의 단점을 보완하기 위해 등장한 LinkedList는 불연속적으로 존재하는 데이터를 단방향으로 연결한 형태로 구성되어 있다.
- java의 LinkedList 클래스는 이전 요소에 대한 참조가 추가되어 있는 Doubly LinkedList로 구현되어 있다.
- 순차적으로 추가/삭제하는 경우 ArrayList가 더 빠르고, 중간 데이터를 추가/삭제하는 경우 LinkedList가 더 빠르다.

### 1-3 Stack
- Stack은 LIFO(선입후출)구조로 되어있다.
- 순차적으로 데이터를 추가하고 삭제하므로 ArrayList와 같은 배열 기반의 컬렉션 클래스가 적합하다.

### 1-4 Queue
- Queue는 FIFO(선입선출) 구조로 되어 있다.
- 첫 번째 저장된 데이터를 꺼내므로 데이터의 추가/삭제가 쉬운 LinkedList로 구현하는 것이 적합하다.
- PriorityQueue는 저장 순서에 관계 없이 우선순위가 높은 것부터 꺼낸다. 저장공간으로 배열을 사용하며, 각 요소를 Heap 자료구조의 형태로 저장한다. null을 저장할 수 없다.
- Deque는 Queue의 변형으로 양쪽 끝에 추가/삭제가 가능하다. 구현체로 ArrayDeque와 LinkedList가 있다.

### 1-5 Iterator, ListIterator
- 컬렉션에 저장된 요소를 접근하는데 사용되는 인터페이스들이다.
- Iterator()는 Collection 인터페이스에 정의된 메서드이다. 컬렉션의 요소에 접근할 때 단방향으로 이동한다.  
- Collection 인터페이스로 구현된 클래스들은 Iterator를 사용할 수 있다.
- ListIterator는 List인터페이스를 구현한 컬렉션에서 양방향으로 이동이 가능하다. 다만 이동하기 전에 반드시 hasNext()나 hasPrevious()를 호출해서 이동할 수 있는지 확인해야 한다.
- Iterator의 remove()는 단독으로 쓰일수 없고, next()와 같이 써야한다. 특정위치의 요소를 삭제하는 것이 아니라 읽어 온 것을 삭제한다.

### 1-6 Arrays
   |메서드|특징|
   |-----|---|
   |copyOf()|배열 전체를 복사해 새로운 배열을 만들어 반환한다.| 
   |copyOfRange()|배열의 일부를 복사해 새로운 배열을 만들어 반환한다. <br> 지정된 범위의 끝은 포함되지 않는다.|
   |fill()|배열의 모든 요소를 지정된 값으로 채운다.|
   |setAll()|배열을 채우는데 사용할 함수형 인터페이스를 매개변수로 받는다.|
   |sort()|배열을 정렬할 때 사용한다.|
   |binarySearch()|배열에 저장된 요소를 검색할 때 사용한다. <br> 이진 검색으로 지정된 값이 저장된 위치를 반환하기 때문에, 배열이 정렬된 상태여야 올바른 결과를 얻는다. <br>검색값과 일치하는 요소들이 여러개 있다면, 어떤 것의 위치가 반환될 지 알 수없다.
   |equals()|두 배열에 저장된 모든 요소를 비교해서 boolean값을 반환한다. <br> 다차원 배열의 비교에는 deepEquals()를 사용한다.
   |toString()|배열의 모든 요소를 문자열로 출력한다. <br> 다차원 배열에서는 deepToString()을 사용한다.
   |asList(Object)|배열을 List에 담아서 반환한다. <br> 반환한 List는 저장된 내용의 변경은 가능하지만 크기를 변경할 수 없다
   |parallel<함수명>()|여러 쓰레드가 작업을 나누어 처리하도록 한다.
   |spliterator()|하나의 작업을 여러 작업으로 나누는 Spliterator를 반환한다.
   |stream()|Collection을 Stream으로 변환한다.



