## 1. 컬렉션 프레임워크(Collections Framework)
- 컬렉션 프레임워크: 데이터 군을 저장하는 클래스들을 표준화한 설계.
- 컬렉션 데이터 그룹을 크게 List, Set, Map 3가지로 분류할 수 있다.

|인터페이스|특징|
|-----|---|
|List|순서가 있는 데이터의 집합 <br> 데이터의 중복을 허용|
|Set|순서를 유지하지 않는 데이터의 집합 <br> 데이터의 중복을 허용하지 않는다.|
|Map|key와 value의 쌍으로 이루어진 데이터 집합 <br> 순서는 유지되지 않는다 <br> 키는 중복을 허용하지 않고 값은 중복을 허용.

### 1-1 ArrayList
- ArrayList는 Object배열을 이용해서 데이터를 순차적으로 저장한다.
- 원소가 삭제될 때 마다 빈 공간을 채우기 위해 나머지 요소들이 자리이동을 한다. 따라서 요소를 삭제할 때 주의해야한다.
- ArrayList는 지정한 크기보다 더 많은 객체를 저장하면 자동적으로 늘어나지만, 이 과정에서 처리시간이 많이 소요된다. 이는 용량을 변경할 때 새로운 배열을 생성한 후 기존의 배열로부터 새로 생성된 배열로 데이터를 복사해서 넣기 때문이다. 따라서 실제 저장할 개수보다 여유를 주는 것이 좋다.

### 1-2 LinkedList
- 배열은 크기를 변경할 수 없고 중간에 데이터를 추가/삭제하는데 시간을 많이 소모한다.
- 이러한 배열의 단점을 보완하기 위해 등장한 LinkedList는 불연속적으로 존재하는 데이터를 단방향으로 연결한 형태로 구성되어 있다.
- Java의 LinkedList 클래스는 이전 요소에 대한 참조가 추가되어 있는 Doubly LinkedList로 구현되어 있다.
- 순차적으로 추가/삭제하는 경우 ArrayList가 더 빠르고, 중간 데이터를 추가/삭제하는 경우 LinkedList가 더 빠르다.

### 1-3 Stack
- Stack은 LIFO(후입선출)구조로 되어있다.
- 순차적으로 데이터를 추가하고 삭제하므로 ArrayList와 같은 배열 기반의 컬렉션 클래스가 적합하다.

### 1-4 Queue
- Queue는 FIFO(선입선출) 구조로 되어 있다.
- 첫 번째 저장된 데이터를 꺼내므로 데이터의 추가/삭제가 쉬운 LinkedList로 구현하는 것이 적합하다.
- PriorityQueue는 저장 순서에 관계 없이 우선순위가 높은 것부터 꺼낸다. 저장공간으로 배열을 사용하며, 각 요소를 Heap 자료구조의 형태로 저장한다. null을 저장할 수 없다.
- Deque는 Queue의 변형으로 양쪽 끝에 추가/삭제가 가능하다. 구현체로 ArrayDeque와 LinkedList가 있다.

### 1-5 Iterator, ListIterator
- 컬렉션에 저장된 요소를 접근하는데 사용되는 인터페이스들이다.
- Iterator()는 Collection 인터페이스에 정의된 메서드이다. 컬렉션의 요소에 접근할 때 단방향으로 이동한다.  
- Collection 인터페이스로 구현된 클래스들은 Iterator를 사용할 수 있다.
- ListIterator는 List인터페이스를 구현한 컬렉션에서 양방향으로 이동이 가능하다. 다만 이동하기 전에 반드시 hasNext()나 hasPrevious()를 호출해서 이동할 수 있는지 확인해야 한다.
- Iterator의 remove()는 단독으로 쓰일수 없고, next()와 같이 써야한다. 특정위치의 요소를 삭제하는 것이 아니라 읽어 온 것을 삭제한다.

### 1-6 Arrays
   |메서드|특징|
   |-----|---|
   |copyOf()|배열 전체를 복사해 새로운 배열을 만들어 반환한다.| 
   |copyOfRange()|배열의 일부를 복사해 새로운 배열을 만들어 반환한다. <br> 지정된 범위의 끝은 포함되지 않는다.|
   |fill()|배열의 모든 요소를 지정된 값으로 채운다.|
   |setAll()|배열을 채우는데 사용할 함수형 인터페이스를 매개변수로 받는다.|
   |sort()|배열을 정렬할 때 사용한다.|
   |binarySearch()|배열에 저장된 요소를 검색할 때 사용한다. <br> 이진 검색으로 지정된 값이 저장된 위치를 반환하기 때문에, 배열이 정렬된 상태여야 올바른 결과를 얻는다. <br>검색값과 일치하는 요소들이 여러개 있다면, 어떤 것의 위치가 반환될 지 알 수없다.
   |equals()|두 배열에 저장된 모든 요소를 비교해서 boolean값을 반환한다. <br> 다차원 배열의 비교에는 deepEquals()를 사용한다.
   |toString()|배열의 모든 요소를 문자열로 출력한다. <br> 다차원 배열에서는 deepToString()을 사용한다.
   |asList(Object)|배열을 List에 담아서 반환한다. <br> 반환한 List는 저장된 내용의 변경은 가능하지만 크기를 변경할 수 없다
   |parallel<함수명>()|여러 쓰레드가 작업을 나누어 처리하도록 한다.
   |spliterator()|하나의 작업을 여러 작업으로 나누는 Spliterator를 반환한다.
   |stream()|Collection을 Stream으로 변환한다.

### 1-7 Comparator, Comparable
- Comparable은 기본 정렬기준을 구현하는데 사용되고, Comparator는 기본 정렬기준 외에 다른 기준으로 정렬하고자할 때 사용된다.
- Comparable을 구현한 클래스들은 기본적으로 오름차순으로 정렬되어있다.
- Arrays.sort()는 Comparator를 지정해주지 않으면 저장하는 객체에 구현된 내용에 따라 정렬된다.
- String의 Comparable구현은 문자열이 사전 순(유니코드의 순서가 작은 값에서 부터 큰 값)으로 정렬되도록 작성되어 있다.

### 1-8 HashSet
- HashSet은 Set 인터페이스를 구현한 컬렉션으로, 중복된 요소를 저장하지 않는다.
- HashSet은 저장순서를 유지하지 않기 때문에, 저장순서를 유지하고자 한다면 LinkedHashSet을 사용해야한다.
- HashSet은 equals()와 hashCode()를 호출하여 중복을 제거하기 때문에 클래스 원소를 삽입하고자 한다면 두 함수를 오버라이딩 해야한다. (hashCode함수는 Objects클래스의 hash함수를 이용해서 오버라이딩하는 것도 가능하다.)
- 오버라이딩을 통해 작성된 hashCode()는 아래 세가지 조건을 만족해야한다.
  1. 동일한 객체에 대해서 여러 번 호출해도 동일한 int값을 반환해야 한다.
  2. equals메서드로 true를 얻은 두 객체에 대해 hashCode()를 호출해서 얻은 결과는 반드시 같아야 한다.
  3. equals메서드를 호출했을 때 false를 반환하는 두 객체는 hashCode()호출에 대해 다른 int값을 반환하는 것이 좋다. (중복되는 경우가 많을수록 검색속도가 떨어진다.)
   
### 1-9 TreeSet
- TreeSet은 이진 검색 트리(Binary Search Tree)라는 자료구조의 형태로 데이터를 저장하는 컬렉션 클래스 이다.
- TreeSet은 이진 검색 트리의 성능을 향상시킨 레드-블랙 트리(Red-Black Tree)로 구현되어 있다.
- Set인터페이스를 구현하여,  중복된 데이터의 저장을 허용하지않고, 저장순서를 유지하지도 않는다.
- 부모 노드는 좌측 자식 노드보다 큰 값을 갖고, 우측 자식 노드보다 작은 값을 갖는다. 해당 정렬 상태를 유지하기 때문에 검색에서 큰 효율을 보인다.
- 데이터를 순차적으로 저장하는 것이 아니기 때문에 저장 위치를 찾아서 저장해야하고, 삭제하는 경우 트리의 일부를 재구성해야 하므로 LinkedList보다 데이터의 추가/삭제 시간이 더 소요된다.

### 1-10 HashMap
- HashMap은 key-value를 묶어서 하나의 데이터로 저장하는 특징을 가지며, 해싱을 사용하기 때문에 검색에 뛰어나다.
- HashMap은 Entry라는 내부 클래스를 정의하고, 다시 Entry타입의 배열을 선언한다. key와 value는 별개의 값이 아니라 서로 관련된 값이기 때문에 각각의 배열로 선언하기 보다는 하나의 클래스로 정의해서 하나의 배열로 다루는 것이 데이터의 무결성(integrity) 측면에서 더 바람직하기 때문이다.
- key와 value를 Object타입으로 저장하기 때문에 어떠한 객체도 저장할 수 있지만, key는 주로 String을 대문자 혹은 소문자로 통일하여 사용한다.
- key 중복을 허용하지 않으며, 새로 추가되는 대신 기존의 값을 덮어쓴다.
- 해싱은 해시함수(hash function)를 이용해서 데이터를 해시테이블(hash table)에 저장하고 검색하는 기법이다.
- 해싱을 구현한 컬렉션 클래스에서는 Object 클래스에 정의된 hashCode()를 호출한다. 객체의 주소를 이용하는 알고리즘으로 해시코드를 만들어 내기 때문에 모든 객체에 대해 hashCode()를 호출한 결과가 서로 유일한 방법이다.
- String 클래스는 hashCode( )를 오버라이딩해서 문자열의 내용으로 해시코드를 만들어낸다. 다른 String인스턴스일지라도 같은 내용의 문자열을 가졌다면 같은 해시코드를 얻는다.

### 1-11 Properties
- Hashtable을 상속받아 구현한 것으로 (String, String)의 형태로 저장하는 컬렉션 클래스이다.
- 주로 애플리케이션의 환경설정과 관련된 속성을 저장하는데 사용되며 데이터를 파일로부터 읽고 쓰는 편리한 기능을 제공한다.
- Properties는 Iterator가 아닌 Enumeration을 사용한다. propertyNames()메서드는 목록의 모든 key가 담긴 Enumeration을 반환한다.

### 1-12 Collections
- Collections는 컬렉션과 관련된 메서드를 제공한다.
- Collections에서는 synchronized를 붙여 동기화 메서드를 사용할 수 있다.
- unmodifiable의 접미사를 갖는 메서드들은 컬렉션을 읽기전용으로 만들어 반환한다. 멀티 쓰레드 프로그래밍에서 여러 쓰레드가 하나의 컬렉션을 공유하다보면 데이터가 손상될 수 있는데, 이를 방지하기 위해 사용할 수 있다.
- singleton 접미사가 달린 메서드들은 하나의 객체만을 저장하는 컬렉션을 반환한다. 반환된 컬렉션은 변경할 수 없다.
- checked 접미사를 갖는 메서드들은 지정된 종류의 객체만 저장할 수 있도록 하는 컬렉션 객체를 반환한다. (호환성 때문에 사용)


